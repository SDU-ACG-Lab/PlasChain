#!/usr/bin/env python

import argparse, os
import copy
import logging
import multiprocessing as mp
import pysam


from scapp_utils import *

import PARAMS

def parse_user_input():
    parser = argparse.ArgumentParser(
        description=
        'SCAPP extracts likely plasmids (and other circular DNA elements) from de novo assembly graphs'
        )
    parser.add_argument('-g','--graph',
     help='(spades 3.50+) assembly graph FASTG file to process; recommended for spades 3.5: before_rr.fastg, for spades 3.6+:assembly_graph.fastg',
     required=True, type=str
     )
    parser.add_argument('-k','--max_k',
        help='integer reflecting maximum k value used by the assembler',
        required=True, type=int, default=77
        )
    parser.add_argument('-b','--bam',
        help='BAM file resulting from aligning reads to contigs file, filtering for best matches',
        required=True, type=str
        )
    parser.add_argument('-l', '--length',
     help='minimum length required for reporting [default: 1000]',
     required=False, type=int, default=1000
     )
    parser.add_argument('-m', '--max_CV',
     help='coefficient of variation used for pre-selection [default: 0.5, higher--> less restrictive]',
      required=False, default=1./2, type=float
      )
    parser.add_argument('-i','--iso',
        help='True or False value reflecting whether data sequenced was an isolated strain',
        required=False, type=bool, default=False
        )
    parser.add_argument('-o','--output_dir',
        help='Output directory',
        required=True, type=str
        )
    parser.add_argument('-p','--num_processes',
        help='Number of processes to use',
        required=False, type=int, default=1
        )
    parser.add_argument('-s','--scores',
            help='Contig plasmid scores file',
            required=False, type=str
        )
    parser.add_argument('-gh','--gene_hits',
            help='Contig plasmid gene hits file',
            required=False, type=str
        )

    # internal thresholds to be passed down to utils functions
    parser.add_argument('-clft','--classification_thresh',
        help='threshold for classifying potential plasmid [0.5]',
        required=False, type=float
    )
    parser.add_argument('-gm','--gene_match_thresh',
        help='threshold for % identity and fraction of length to match plasmid genes [0.75]',
        required=False, type=float
    )
    parser.add_argument('-sls','--selfloop_score_thresh',
        help='threshold for self-loop plasmid score [0.9]',
        required=False, type=float
    )
    parser.add_argument('-slm','--selfloop_mate_thresh',
        help='threshold for self-loop off loop mates [0.1]',
        required=False, type=float
    )
    parser.add_argument('-cst','--chromosome_score_thresh',
        help='threshold for high confidence chromosome node score [0.2]',
        required=False, type=float
    )
    parser.add_argument('-clt','--chromosome_len_thresh',
        help='threshold for high confidence chromosome node length [10000]',
        required=False, type=float
    )
    parser.add_argument('-pst','--plasmid_score_thresh',
        help='threshold for high confidence plasmid node score [0.9]',
        required=False, type=float
    )
    parser.add_argument('-plt','--plasmid_len_thresh',
        help='threshold for high confidence plasmid node length [10000]',
        required=False, type=float
    )
    parser.add_argument('-cd','--good_cyc_dominated_thresh',
        help='threshold for # of mate-pairs off the cycle in dominated node [0.5]',
        required=False, type=float
    )
    parser.add_argument('-path','--metaSPAdes_path',
        help='contigs path generated by metaSPAdes',
        required=True, type=str
    )
    parser.add_argument('-min_clen','--min_contig_path_len',
        help='the minimum lengths of contigs path used',
        default=4, type=int
    )
    

    return parser.parse_args()

def run_scapp(fastg, outdir, bampath, num_procs, max_k, \
                    genes_file, use_genes, scores_file, use_scores, path_file,\
                    max_CV, min_length,min_contig_path_len, ISO=False):
    ''' Run SCAPP'''

    logger = logging.getLogger("scapp_logger")

    basename, _ = os.path.splitext(os.path.basename(fastg))
    fasta_ofile = os.path.join(outdir, basename+".cycs.fasta")
    cycs_ofile = os.path.join(outdir, basename+".cycs.paths.txt")
    loop_ofile = os.path.join(outdir,basename+".self_loops.fasta")
    contig_path_ofile = os.path.join(outdir,basename+".contig.fasta")
    contig_path_score_ofile = os.path.join(outdir,basename+".contig.score.fasta")

    f_cycs_fasta = open(fasta_ofile, 'w') # output 1 - fasta of sequences
    f_cyc_paths = open(cycs_ofile, 'w') # output 2 - file containing path name (corr. to fasta),
    f_long_self_loops = open(loop_ofile,'w') # output 3 - file of self-loop fasta sequences
    bamfile = pysam.AlignmentFile(bampath)

    # graph processing begins
    G = get_fastg_digraph(fastg)

    logger.info("Removing %d isolate nodes" % len(list(nx.isolates(G))))
    G.remove_nodes_from(list(nx.isolates(G)))
    # first graph is used to calculate path CV during peeling cycles
    original_comp = copy.deepcopy(G)

    path_count = 0
    SEQS, id_to_fullname = get_fastg_seqs_dict(fastg,G)

    # remove dead end to trim contig path
    remove_dead_ends(original_comp)
    
    print(f"get contig path which is longer than {min_contig_path_len}")
    path_dict,contigs_path_name_dict, node_to_contig, scores_dict= get_contig_path(path_file, id_to_fullname,SEQS,original_comp,contig_path_ofile,contig_path_score_ofile,min_contig_path_len=min_contig_path_len,max_k=max_k,num_procs=num_procs)
    print(f"get valid PE support...")
    st = time.time()
    mean, std = estimate_insert_size_distribution(bamfile)
    pe_contigs_path_dict, valid_pairs = get_pe_support_evidence(G, bamfile, mean, std, max_k)
    pe_support_dict = build_pe_support_dict(pe_contigs_path_dict)
    G.graph['pe_support_data'] = pe_support_dict
    logger.info(f"get valid PE support consuming {time.time() - st} s")

    # logger.info("path_dict:\n")
    # for key in path_dict.keys():
    #     logger.info(f"{key}\t {path_dict[key]}\n")

    # add a score to every node
    get_node_freq_vec(G,SEQS)
    if use_scores:
        get_node_scores(scores_file,G)

    # keep track of the nodes that have plasmid genes on them
    if use_genes:
        get_gene_nodes(genes_file,G)

    # add contig path with hi conf node as fisrt node
    proxy_contig_dict =  add_contig_to_path_dict(G,scores_dict,path_dict,contigs_path_name_dict,node_to_contig,use_genes,use_scores)
    # gets set of long simple loops, removes short
    # simple loops from graph
    long_self_loops = get_long_self_loops(G, min_length, SEQS, bamfile, use_scores, use_genes, max_k)

    for nd in long_self_loops:
        name = get_spades_type_name(path_count, nd,
        SEQS, max_k, G, get_cov_from_spades_name(nd[0]))
        path_count += 1

        seq = get_seq_from_path(nd, SEQS, max_k_val=max_k)
        print(nd)
        print(" ")
        if len(seq)>=min_length:
            f_cycs_fasta.write(">" + name + "\n" + seq + "\n")
            f_long_self_loops.write(">" + name + "\n" + seq + "\n")
            f_cyc_paths.write(name + "\n" +str(nd[0])+ "\n" +
             str(get_num_from_spades_name(nd[0])) + "\n")
    
    # 获取强连通分支
    comps = (G.subgraph(c).copy() for c in nx.strongly_connected_components(G))

    # 删除hi conf chromosome 后，再更新强连通分支
    if use_scores:
        # Remove nodes that are most likely chromosomal
        # This may
        smaller_comps = set()
        for comp in comps:
            remove_hi_confidence_chromosome(comp,node_to_contig)
            smaller_comps.update((comp.subgraph(c).copy() for c in nx.strongly_connected_components(comp)))
        comps = smaller_comps

    ###################################
    # iterate through SCCs looking for cycles
    ###################################

    #multiprocessing to find shortest paths
    pool = mp.Pool(num_procs)

    print("================== Added paths ====================")
    logger.info("================== Added paths ====================")

    VISITED_NODES = set([]) # used to avoid problems due to RC components
    redundant = False
    logger.info(f"{len(comps)} components are going to be processed...")
    

    all_comps = len(comps)
    processed_comps = 0
    merge_cost = 0
    before_merge_path_count=0
    # 创建一个排序key后排序，确保每次结果一致
    for c in sorted(comps, key=lambda c: (len(c.nodes()), component_sort_key(c))):
        # logger.info(f"start processing {processed_comps}")
        processed_comps += 1
	    # check if any nodes in comp in visited nodes
        # if so continue
        # logger.info(f"cur comp has nodes: {str(c.nodes())}")
        for node in c.nodes():
             # 如果节点已经被访问，说明其对应的反向互补的强连通分支已经处理过，直接退出当前循环
             if node in VISITED_NODES:
                logger.info(f"{node} had been visited ,pass {processed_comps}/ {all_comps}")
                print(f"{processed_comps}/ {all_comps} have been processed...")
                redundant = True
                break
        if redundant:
             redundant = False
             continue # have seen the RC version of component
        COMP = nx.DiGraph()
        COMP = c.to_directed()
        
    
        rc_nodes = [rc_node(n) for n in COMP.nodes()]
        # logger.info(f"add {str(rc_nodes)}")
        # logger.info(f"add {str(COMP.nodes())}")
        VISITED_NODES.update(COMP.nodes())
        VISITED_NODES.update(rc_nodes)
        # 核心函数
        # 参数的前三个， COMP当前强连通分支， G原图，用于计算原图(包含dead end)中的discounted coverage
        path_set, merge_time,path_set_before_merge = process_component(COMP, G ,max_k, min_length, max_CV, SEQS, pool, path_dict,node_to_contig,contigs_path_name_dict,proxy_contig_dict
                                                                       ,valid_pairs,use_scores, use_genes, num_procs)
        merge_cost+=merge_time
        for p in path_set:
            name = get_spades_type_name(path_count, p[0], SEQS, max_k, G, p[1])
            seq = get_seq_from_path(p[0], SEQS, max_k_val=max_k)
            # print(p[0])
            # print(" ")
            if len(seq)>=min_length:
                f_cycs_fasta.write(">" + name + "\n" + seq + "\n")
                f_cyc_paths.write(name + "\n" +str(p[0])+ "\n" +
                 str([get_num_from_spades_name(n) for n in p[0]]) + "\n")
            path_count += 1
        logger.info(f"{processed_comps}/ {all_comps} have been processed...")
        print(f"{processed_comps}/ {all_comps} have been processed...")
    logger.info(f"merge cycle consumes {merge_cost} seconds")
    pool.close()
    pool.join()
    f_cycs_fasta.close()
    f_cyc_paths.close()
    f_long_self_loops.close()


def main():

    ####### entry point  ##############

    args = parse_user_input()
    num_procs = args.num_processes
    fastg = args.graph
    max_k = args.max_k
    # files_dir = os.path.dirname(fp.name)
    if args.scores:
        use_scores = True
    else: use_scores = False
    if args.gene_hits:
        use_genes = True
    else: use_genes = False
    path_file = args.metaSPAdes_path
    bampath = args.bam
    min_length = args.length
    ISO = args.iso
    min_contig_path_len = args.min_contig_path_len

    # default threshold vaariables
    PARAMS.load_params_json()
    if args.max_CV:
        PARAMS.MAX_CV = args.max_CV
    if args.length:
        PARAMS.MIN_LENGTH = args.length
    if args.classification_thresh:
        PARAMS.CLASSIFICATION_THRESH = args.classification_thresh
    if args.gene_match_thresh:
        PARAMS.GENE_MATCH_THRESH = args.gene_match_thresh
    if args.selfloop_score_thresh:
        PARAMS.SELF_LOOP_SCORE_THRESH = args.selfloop_score_thresh
    if args.selfloop_mate_thresh:
        PARAMS.SELF_LOOP_MATE_THRESH = args.selfloop_mate_thresh
    if args.chromosome_score_thresh:
        PARAMS.CHROMOSOME_SCORE_THRESH = args.chromosome_score_thresh
    if args.chromosome_len_thresh:
        PARAMS.CHROMOSOME_LEN_THRESH = args.CHROMOSOME_LEN_THRESH
    if args.plasmid_score_thresh:
        PARAMS.PLASMID_SCORE_THRESH = args.plasmid_score_thresh
    if args.plasmid_len_thresh:
        PARAMS.PLASMID_LEN_THRESH
    if args.good_cyc_dominated_thresh:
        PARAMS.GOOD_CYC_DOMINATED_THRESH = args.good_cyc_dominated_thresh

    # Set up logging and write config and options to the log file
    logfile = os.path.join(args.output_dir,"scapp.log")
    logging.basicConfig(filemode='w', filename=logfile, level=logging.INFO, format='%(asctime)s: %(message)s', datefmt='%d/%m/%Y %H:%M')
    logger = logging.getLogger("scapp_logger")

    run_scapp(fastg, args.output_dir, bampath, num_procs, max_k, \
                    args.gene_hits, use_genes, args.scores, use_scores,path_file, \
                    PARAMS.MAX_CV, min_length,min_contig_path_len,ISO)


if __name__ == '__main__':
    main()
